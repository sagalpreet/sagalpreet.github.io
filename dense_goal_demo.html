<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeepMind Kiosk: DDGC Full Presentation</title>

    <!-- LOAD MATHJAX (LATEX ENGINE) -->
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        :root {
            --dm-blue: #4285F4;
            --dm-black: #202124;
            --dm-gray: #5f6368;
            --goal-green: #34A853;
            --nongoal-red: #EA4335;
            --bg-color: #f8f9fa;
        }

        body {
            font-family: 'Google Sans', 'Arial', sans-serif;
            background-color: var(--bg-color);
            color: var(--dm-black);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        /* --- NAVIGATION --- */
        nav {
            background: white;
            width: 100%;
            padding: 15px 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: center;
            gap: 40px;
            z-index: 100;
        }

        .nav-item {
            font-size: 16px;
            font-weight: 600;
            color: var(--dm-gray);
            cursor: pointer;
            padding-bottom: 5px;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
        }

        .nav-item:hover {
            color: var(--dm-blue);
        }

        .nav-item.active {
            color: var(--dm-blue);
            border-bottom-color: var(--dm-blue);
        }

        /* --- CONTENT CONTAINERS --- */
        .tab-content {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
            padding-top: 20px;
            animation: fadeIn 0.4s ease;
        }

        .tab-content.active {
            display: flex;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 24px;
            margin-bottom: 5px;
        }

        h3 {
            color: var(--dm-gray);
            font-weight: 400;
            margin-top: 0;
            margin-bottom: 20px;
        }

        /* --- SHARED STYLES --- */
        .canvas-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.06);
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .controls {
            background: white;
            padding: 10px 20px;
            border-radius: 50px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            border: 2px solid transparent;
            border-radius: 40px;
            font-size: 14px;
            cursor: pointer;
            font-weight: 600;
            background: transparent;
            color: var(--dm-gray);
            transition: 0.2s;
        }

        button:hover {
            background: #f1f3f4;
        }

        button.active {
            transform: scale(1.05);
        }

        #btn-rl.active {
            background: #e8f0fe;
            color: var(--dm-blue);
        }

        #btn-rand.active {
            background: #fce8e6;
            color: var(--nongoal-red);
        }

        #btn-ddgc.active {
            background: #e6f4ea;
            color: var(--goal-green);
        }

        /* --- TAB 2 SPECIFIC --- */
        .algo-step-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .algo-box {
            background: white;
            padding: 20px;
            border-radius: 12px;
            width: 250px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            text-align: center;
        }

        .bar-chart {
            display: flex;
            align-items: flex-end;
            justify-content: space-around;
            height: 150px;
            margin-top: 15px;
            border-bottom: 2px solid #ddd;
        }

        .bar {
            width: 40px;
            background: var(--dm-blue);
            transition: height 0.5s ease;
            position: relative;
        }

        .bar-label {
            position: absolute;
            bottom: -25px;
            width: 100%;
            text-align: center;
            font-size: 12px;
        }

        .step-desc {
            font-size: 13px;
            color: var(--dm-gray);
            min-height: 40px;
            margin-top: 5px;
        }

        /* --- TAB 3 SPECIFIC --- */
        .math-container {
            max-width: 800px;
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
        }

        .equation {
            font-size: 120%;
            /* Scale up MathJax */
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }

        .theorem-box {
            border-left: 4px solid var(--dm-blue);
            padding-left: 20px;
            margin-bottom: 30px;
        }

        .slider-container {
            margin-top: 30px;
            text-align: center;
        }

        input[type=range] {
            width: 300px;
            accent-color: var(--dm-blue);
        }

        /* --- ADD TO CSS --- */

        /* 1. Make boxes dim inactive ones and pop the active one */
        .algo-box {
            /* Existing styles... */
            transition: all 0.3s ease;
            opacity: 0.5;
            /* Dim by default */
            border: 2px solid transparent;
            /* Prepare for border */
        }

        .algo-box.active-box {
            border-color: var(--dm-blue);
            box-shadow: 0 8px 20px rgba(66, 133, 244, 0.2);
            opacity: 1;
            transform: translateY(-5px);
        }

        /* 2. The Curved Feedback Arrow */
        .algo-step-container {
            position: relative;
            /* Needed to anchor the absolute arrow */
            padding-bottom: 60px;
            /* Space for the arrow */
        }

        .feedback-loop {
            position: absolute;
            bottom: 0px;
            left: 10%;
            width: 80%;
            height: 40px;
            z-index: -1;
            opacity: 0;
            /* Hidden by default */
            transition: opacity 0.5s;
        }

        .feedback-loop.visible {
            opacity: 1;
        }

        /* 3. Action Button Styling */
        #btn-sequence {
            background-color: var(--dm-black);
            color: white;
            min-width: 180px;
            /* Prevent jumping width when text changes */
        }

        #btn-sequence:hover {
            background-color: #3c4043;
        }

        /* --- ADD TO CSS --- */

        /* Hyperparameter Tuner Styling */
        .tuner-container {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 20px;
        }

        .tuner-group {
            text-align: center;
        }

        .tuner-label {
            font-size: 14px;
            font-weight: bold;
            color: var(--dm-gray);
            margin-bottom: 8px;
            display: block;
        }

        .tuner-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #f1f3f4;
            padding: 5px 15px;
            border-radius: 20px;
        }

        .btn-tune {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: none;
            background: white;
            color: var(--dm-black);
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-tune:hover {
            background: var(--dm-blue);
            color: white;
        }

        .tuner-val {
            font-family: monospace;
            font-size: 16px;
            width: 40px;
        }

        /* Graph Axis Labels */
        .axis-label {
            position: absolute;
            font-size: 11px;
            color: #888;
        }

        /* --- CODE BLOCK STYLES --- */
        .code-container {
            background: #2d2d2d;
            color: #ccc;
            padding: 20px;
            border-radius: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            width: 100%;
            max-width: 600px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border-left: 5px solid var(--dm-blue);
        }

        .kw {
            color: #cc99cd;
            font-weight: bold;
        }

        /* Keywords (for, if) */
        .fn {
            color: #f08d49;
        }

        /* Functions */
        .var {
            color: #61aeee;
        }

        /* Variables */
        .comment {
            color: #999;
            font-style: italic;
        }

        .num {
            color: #f8c555;
        }

        /* --- TAB 4 SPLIT LAYOUT --- */
        .split-container {
            display: flex;
            gap: 40px;
            align-items: flex-start;
            width: 100%;
        }

        .left-panel {
            flex: 3;
            /* Takes up 60% of space */
            display: flex;
            flex-direction: column;
        }

        .right-panel {
            flex: 2;
            /* Takes up 40% of space */
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #e0e0e0;
        }

        /* Definition Table Styles */
        .def-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .def-table th {
            text-align: left;
            color: var(--dm-gray);
            border-bottom: 2px solid #ddd;
            padding-bottom: 10px;
            margin-bottom: 10px;
            font-size: 12px;
            text-transform: uppercase;
        }

        .def-table td {
            padding: 10px 5px;
            border-bottom: 1px solid #eee;
            vertical-align: middle;
        }

        .def-table tr:last-child td {
            border-bottom: none;
        }

        .symbol-col {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-weight: bold;
            font-size: 15px;
            color: var(--dm-black);
            width: 60px;
        }

        .desc-col {
            color: #444;
            line-height: 1.4;
        }

        /* --- FAQ ACCORDION STYLES --- */
        .faq-container {
            max-width: 800px;
            width: 100%;
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            /* Allow scrolling if content is long */
            padding-bottom: 50px;
        }

        .accordion-item {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            border: 1px solid #eee;
            overflow: hidden;
            transition: all 0.2s ease;
        }

        .accordion-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .accordion-header {
            padding: 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fff;
            user-select: none;
        }

        .accordion-question {
            font-weight: bold;
            color: var(--dm-black);
            font-size: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .q-icon {
            background: #e8f0fe;
            color: var(--dm-blue);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }

        .accordion-icon {
            font-size: 18px;
            color: var(--dm-gray);
            transition: transform 0.3s ease;
        }

        /* Open State */
        .accordion-item.open .accordion-icon {
            transform: rotate(180deg);
        }

        .accordion-item.open .accordion-header {
            background: #f8f9fa;
            border-bottom: 1px solid #eee;
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background: white;
            color: #444;
            line-height: 1.6;
            font-size: 14px;
        }

        .accordion-body {
            padding: 20px;
        }

        .highlight-box {
            background: #f1f3f4;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 13px;
            border-left: 3px solid var(--dm-blue);
        }
    </style>
</head>

<body>

    <!-- NAVIGATION -->
    <nav>
        <div class="nav-item active" onclick="switchTab(1)">1. The Problem (Simulated)</div>
        <div class="nav-item" onclick="switchTab(2)">2. The Algorithm (Visualized)</div>
        <div class="nav-item" onclick="switchTab(3)">3. Objective & Algorithm</div>
        <div class="nav-item" onclick="switchTab(4)">4. Theoretical Guarantees</div>
        <div class="nav-item" onclick="switchTab(5)">5. FAQs</div>
    </nav>

    <!-- TAB 1: THE SIMULATION -->
    <div id="tab1" class="tab-content active">
        <h1>Density / Diversity Double Bind</h1>
        <h3>Standard RL is Myopic. Max Entropy is Wasteful.</h3>

        <div class="controls">
            <button id="btn-rl" onclick="setMode('RL')" class="active">Standard RL</button>
            <button id="btn-rand" onclick="setMode('RANDOM')">Max Entropy</button>
            <button id="btn-ddgc" onclick="setMode('DDGC')">DDGC (Ours)</button>
        </div>

        <div class="canvas-container">
            <canvas id="simCanvas"></canvas>
        </div>

        <div style="display:flex; gap: 40px; text-align:center;">
            <div>
                <div style="font-size:24px; font-weight:bold; color:var(--dm-blue)" id="t1-ret">0.0</div>
                <div style="font-size:12px; color:var(--dm-gray)">RETURN</div>
            </div>
            <div>
                <div style="font-size:24px; font-weight:bold; color:var(--goal-green)" id="t1-div">0.0</div>
                <div style="font-size:12px; color:var(--dm-gray)">DIVERSITY</div>
            </div>
            <div>
                <div style="font-size:24px; font-weight:bold; color:var(--nongoal-red)" id="t1-waste">0%</div>
                <div style="font-size:12px; color:var(--dm-gray)">WASTE</div>
            </div>
        </div>
    </div>

    <!-- TAB 2: THE ALGORITHM -->
    <div id="tab2" class="tab-content">
        <h1>Iterative Mixture Learning</h1>
        <h3>Visualizing the Frank-Wolfe Optimization Loop</h3>

        <div class="controls">
            <button onclick="resetAlgo()">Reset</button>
            <!-- Button text will change dynamically via JS -->
            <button id="btn-sequence" onclick="advanceAlgo()">1. Calculate Reward</button>
        </div>

        <div class="algo-step-container">

            <!-- Box 1 (Starts Active) -->
            <div class="algo-box active-box" id="box-1">
                <h4>1. Current Mixture</h4>
                <div class="step-desc">Aggregate distribution: $\bar{\pi}_{k-1}$</div>
                <div class="bar-chart" id="chart-mixture"></div>
            </div>

            <div style="display:flex; align-items:center; font-size:24px; color:#ccc;">&rarr;</div>

            <!-- Box 2 -->
            <div class="algo-box" id="box-2">
                <h4>2. Custom Reward</h4>
                <div class="step-desc">Target the gaps: $r = 1 - d(s)$</div>
                <div class="bar-chart" id="chart-reward"></div>
            </div>

            <div style="display:flex; align-items:center; font-size:24px; color:#ccc;">&rarr;</div>

            <!-- Box 3 -->
            <div class="algo-box" id="box-3">
                <h4>3. New Policy</h4>
                <div class="step-desc">Greedy on Reward: $\mu_k$</div>
                <div class="bar-chart" id="chart-policy"></div>
            </div>

            <!-- Feedback Loop SVG -->
            <svg class="feedback-loop" id="feedback-arrow" viewBox="0 0 500 60" preserveAspectRatio="none">
                <!-- Curve from Right back to Left -->
                <path d="M 450 10 Q 250 60 50 10" stroke="#4285F4" stroke-width="4" fill="none"
                    stroke-dasharray="10,5" />
                <polygon points="50,10 60,0 60,20" fill="#4285F4" />
                <text x="250" y="55" text-anchor="middle" fill="#4285F4" font-weight="bold" font-size="20">Update
                    Mixture</text>
            </svg>

        </div>

        <div style="margin-top:20px; font-size:14px; color:var(--dm-gray)">
            Iteration $k=$ <span id="iter-count" style="font-weight:bold; color:var(--dm-black)">0</span> |
            Weight $\lambda_k=$ <span id="lambda-val">1.0</span>
        </div>
    </div>

    <!-- TAB 3: OBJECTIVE & ALGORITHM -->
    <div id="tab3" class="tab-content">
        <h1>The Core Logic</h1>
        <h3>Convex Optimization meets Reinforcement Learning</h3>

        <div class="math-container" style="max-width: 900px; display:flex; gap:30px; align-items:flex-start;">

            <!-- LEFT: OBJECTIVE -->
            <div style="flex:1;">
                <div class="theorem-box" style="margin-bottom:15px;">
                    <b>The Objective Function:</b><br>
                    Maximize Return while minimizing Concentration (Gini Index).
                </div>

                <div class="equation" style="font-size: 120%; padding: 20px;">
                    $$ \mathcal{Z}(\bar{\pi}) = \underbrace{\sum_{s\in \mathcal{S}^+} d[\bar{\pi}](s)}_{\text{Return}} -
                    \underbrace{\frac{1}{2} \sum_{s\in \mathcal{S}^+} d[\bar{\pi}](s)^2}_{\text{Concentration}} $$
                </div>

                <p style="color:var(--dm-gray); font-size:14px; line-height:1.5;">
                    By subtracting the squared density, we penalize "putting all eggs in one basket."
                    Since this objective is <b>concave</b>, we can use the Frank-Wolfe algorithm to solve it
                    iteratively.
                </p>
            </div>

            <!-- RIGHT: ALGORITHM -->
            <div style="flex:1;">
                <div class="code-container">
                    <div
                        style="margin-bottom:10px; color:#fff; font-weight:bold; border-bottom:1px solid #555; padding-bottom:5px;">
                        Algorithm 1: DDGC
                    </div>

                    <span class="kw">Input:</span> MDP $\mathcal{M}$<br>
                    <span class="kw">Initialize:</span> Mixture $\bar{\pi}_0$<br><br>

                    <span class="kw">for</span> k = 1 <span class="kw">to</span> K <span class="kw">do</span><br>

                    &nbsp;&nbsp;<span class="comment">// 1. Estimate current coverage</span><br>
                    &nbsp;&nbsp;$\hat{d}_k(s) \leftarrow$ <span
                        class="fn">EstimateDensity</span>($\bar{\pi}_{k-1}$)<br><br>

                    &nbsp;&nbsp;<span class="comment">// 2. Compute "Gap" Reward</span><br>
                    &nbsp;&nbsp;$r_k(s) \leftarrow 1 - \hat{d}_k(s)$<br><br>

                    &nbsp;&nbsp;<span class="comment">// 3. Solve Offline RL Sub-problem</span><br>
                    &nbsp;&nbsp;$\mu_k \leftarrow$ <span class="fn">FittedQIteration</span>($r_k$)<br><br>

                    &nbsp;&nbsp;<span class="comment">// 4. Update Mixture (Frank-Wolfe)</span><br>
                    &nbsp;&nbsp;$\bar{\pi}_k \leftarrow (1-\alpha)\bar{\pi}_{k-1} + \alpha\mu_k$<br>

                    <span class="kw">end for</span><br>
                    <span class="kw">return</span> $\bar{\pi}_K$
                </div>
            </div>

        </div>
    </div>

    <!-- TAB 4: THEORETICAL GUARANTEES -->
    <div id="tab4" class="tab-content">
        <h1>Theoretical Guarantees</h1>
        <h3>Full Finite-Sample Convergence Bound</h3>

        <div class="math-container" style="max-width: 1100px;">

            <div class="split-container">

                <!-- LEFT PANEL: THE MATH -->
                <div class="left-panel">
                    <div class="theorem-box">
                        <b>Theorem 3.1:</b> With high probability $1 - (\delta + \delta_d)$, the sub-optimality gap
                        $h(\bar{\pi}_K)$ is bounded by:
                    </div>

                    <!-- THE EXACT BOUND -->
                    <div class="equation" style="font-size: 110%; padding: 20px; text-align: left;">
                        $$
                        \begin{aligned}
                        h(\bar{\pi}_K) \leq \quad & \color{#4285F4}{\mathcal{O}\left(\frac{1}{K}\right)} \\
                        & + \color{#F4B400}{\mathcal{O}(\gamma^{H}) + \mathcal{O}(\gamma^{N_{\text{FQI}}}) +
                        \mathcal{O}(\epsilon_{\text{approx}})} \\
                        & + \color{#EA4335}{\mathcal{O}\left(\sqrt{\frac{\log(K\text{dim}_\mathcal{F}/\delta) +
                        \text{dim}_\mathcal{F}\log(HN_T)}{HN_T}}\right)} \\
                        & + \color{#EA4335}{\mathcal{O}\left(\sqrt{\frac{1}{N_T}\log(K/\delta_d)}\right)}
                        \end{aligned}
                        $$
                    </div>

                    <!-- BREAKDOWN CARDS (Compact Row) -->
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <!-- Blue -->
                        <div
                            style="flex: 1; background: #e8f0fe; padding: 12px; border-radius: 8px; border-left: 4px solid #4285F4;">
                            <h4 style="color: #1967d2; margin: 0; font-size: 13px;">Optimization Rate</h4>
                            <p style="font-size: 12px; color: #555; margin: 5px 0 0 0;">Frank-Wolfe convergence.</p>
                        </div>
                        <!-- Orange -->
                        <div
                            style="flex: 1; background: #fef7e0; padding: 12px; border-radius: 8px; border-left: 4px solid #F4B400;">
                            <h4 style="color: #b06000; margin: 0; font-size: 13px;">Systematic Bias</h4>
                            <p style="font-size: 12px; color: #555; margin: 5px 0 0 0;">Compute & Model limits.</p>
                        </div>
                        <!-- Red -->
                        <div
                            style="flex: 1; background: #fce8e6; padding: 12px; border-radius: 8px; border-left: 4px solid #EA4335;">
                            <h4 style="color: #c5221f; margin: 0; font-size: 13px;">Sample Complexity</h4>
                            <p style="font-size: 12px; color: #555; margin: 5px 0 0 0;">Finite data variance.</p>
                        </div>
                    </div>
                </div>

                <!-- RIGHT PANEL: DEFINITIONS -->
                <div class="right-panel">
                    <table class="def-table">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Definition</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="symbol-col">$K$</td>
                                <td class="desc-col">Number of Policy Mixture Iterations</td>
                            </tr>
                            <tr>
                                <td class="symbol-col">$N_T$</td>
                                <td class="desc-col">Number of Trajectories (Sample Size)</td>
                            </tr>
                            <tr>
                                <td class="symbol-col">$\gamma$</td>
                                <td class="desc-col">Discount Factor (Time Horizon)</td>
                            </tr>
                            <tr>
                                <td class="symbol-col">$H$</td>
                                <td class="desc-col">Episode Horizon Length</td>
                            </tr>
                            <tr>
                                <td class="symbol-col">$N_{\text{FQI}}$</td>
                                <td class="desc-col">Fitted Q-Iteration Steps</td>
                            </tr>
                            <tr>
                                <td class="symbol-col">$\epsilon_{\text{approx}}$</td>
                                <td class="desc-col">Inherent Bellman Approximation Error</td>
                            </tr>
                            <tr>
                                <td class="symbol-col">$\text{dim}_\mathcal{F}$</td>
                                <td class="desc-col">Pseudo-dimension of Function Class $\mathcal{F}$</td>
                            </tr>
                            <tr>
                                <td class="symbol-col">$\delta, \delta_d$</td>
                                <td class="desc-col">High-probability confidence parameters</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

            </div>
        </div>
    </div>

    <!-- TAB 5: FAQs -->
    <div id="tab5" class="tab-content">
        <h1>Frequently Asked Questions</h1>
        <h3>Common questions regarding settings, baselines, and practical usage.</h3>

        <div class="faq-container">

            <!-- Q1: Goal Conditioned RL -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <div class="accordion-question">
                        <div class="q-icon">?</div>
                        Why not just use Goal-Conditioned RL (GCRL)?
                    </div>
                    <div class="accordion-icon">&#9660;</div>
                </div>
                <div class="accordion-content">
                    <div class="accordion-body">
                        GCRL assumes you can <i>query</i> a specific goal state (e.g., "Go to coordinate X,Y").
                        <br><br>
                        Our setting addresses <b>Discovery</b>: The agent doesn't know what the valid goals are yet. It
                        must explore to find them (Oracle) and then learn a policy to cover them.
                        <div class="highlight-box">
                            <b>Analogy:</b> GCRL is "Drive to this specific address." DDGC is "Find all the good
                            restaurants in the city and visit them equally."
                        </div>
                    </div>
                </div>
            </div>

            <!-- Q2: Real World Relevance -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <div class="accordion-question">
                        <div class="q-icon">?</div>
                        Is the "Oracle Classifier" a realistic assumption?
                    </div>
                    <div class="accordion-icon">&#9660;</div>
                </div>
                <div class="accordion-content">
                    <div class="accordion-body">
                        Yes. This matches the emerging field of <b>RL on Verifiable Rewards (RLVR)</b>.
                        <ul>
                            <li><b>Code Gen:</b> It's easy to check if code runs (Oracle), but hard to find all valid
                                solutions.</li>
                            <li><b>Chemistry:</b> It's easy to simulate stability (Oracle), but hard to enumerate all
                                stable molecules.</li>
                        </ul>
                        Standard RL collapses to the single easiest solution (Mode Collapse). DDGC discovers the full
                        diversity of valid solutions.
                    </div>
                </div>
            </div>

            <!-- Q3: Gini vs Entropy -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <div class="accordion-question">
                        <div class="q-icon">?</div>
                        Why maximize Gini Index instead of Shannon Entropy?
                    </div>
                    <div class="accordion-icon">&#9660;</div>
                </div>
                <div class="accordion-content">
                    <div class="accordion-body">
                        Two reasons: <b>Stability</b> and <b>Theory</b>.
                        <br><br>
                        1. <b>Bounded Rewards:</b> The gradient of Entropy ($\log p$) explodes to $-\infty$ when
                        probability is near zero. The gradient of Gini ($1-p$) is always bounded between 0 and 1. This
                        stabilizes the offline RL step.
                        <br>
                        2. <b>Convergence:</b> Gini has a bounded curvature constant ($C_\mathcal{Z}$), which is a
                        requirement for our Frank-Wolfe convergence proof (Theorem 3.1).
                    </div>
                </div>
            </div>

            <!-- Q4: Compute Cost -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <div class="accordion-question">
                        <div class="q-icon">?</div>
                        Is training a mixture expensive?
                    </div>
                    <div class="accordion-icon">&#9660;</div>
                </div>
                <div class="accordion-content">
                    <div class="accordion-body">
                        It is comparable to state-of-the-art baselines like SMM.
                        <br><br>
                        While we maintain $K$ policies (e.g., $K=8$), we train them sequentially. During inference or
                        training, only one network is active at a time.
                        <div class="highlight-box">
                            <b>Ant Environment (V100 GPU):</b><br>
                            SAC: ~6h 45m<br>
                            DDGC: ~8h 31m (Comparable to SMM)
                        </div>
                    </div>
                </div>
            </div>

            <!-- Q5: Theory vs Practice -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <div class="accordion-question">
                        <div class="q-icon">?</div>
                        How does the Goal Buffer affect the theory?
                    </div>
                    <div class="accordion-icon">&#9660;</div>
                </div>
                <div class="accordion-content">
                    <div class="accordion-body">
                        It actually <b>improves</b> the theoretical bounds.
                        <br><br>
                        The theoretical bound depends on the "Concentrability Coefficient" ($C$)â€”essentially, how well
                        we cover the state space. By using a Goal Buffer and Exploratory Sampling, we ensure the
                        behavior policy has non-zero mass over goal regions, keeping $C$ finite and minimizing the error
                        term in the Offline RL step.
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
        // --- HIGH DPI CANVAS SETUP ---
        function setupCanvas(canvas, width, height) {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            return ctx;
        }

        // --- TAB SWITCHING LOGIC ---
        function switchTab(tabNum) {
            document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
            document.querySelectorAll('.nav-item')[tabNum - 1].classList.add('active');
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById('tab' + tabNum).classList.add('active');

            // Sim logic only for Tab 1
            isSimRunning = (tabNum === 1);
            if (isSimRunning) animateSim();
        }

        // ==========================================
        // TAB 1: SIMULATION LOGIC
        // ==========================================
        const canvas = document.getElementById('simCanvas');
        const LOGICAL_W = 850;
        const LOGICAL_H = 450;
        const ctx = setupCanvas(canvas, LOGICAL_W, LOGICAL_H);

        const NODE_RADIUS = 24;
        let isSimRunning = true;

        const nodes = [
            { id: 'S0', x: 425, y: 50, type: 'start', label: 'Start' },
            { id: 'G1', x: 150, y: 250, type: 'goal', label: 'G1' },
            { id: 'N1', x: 425, y: 200, type: 'nongoal', label: 'N1' },
            { id: 'G2', x: 350, y: 350, type: 'goal', label: 'G2' },
            { id: 'G3', x: 500, y: 350, type: 'goal', label: 'G3' },
            { id: 'N2', x: 700, y: 150, type: 'nongoal', label: 'Trap' },
            { id: 'N3', x: 750, y: 250, type: 'nongoal', label: 'Trap' },
            { id: 'N4', x: 700, y: 350, type: 'nongoal', label: 'Trap' },
        ];

        const connections = [
            { from: 'S0', to: 'G1' }, { from: 'S0', to: 'N1' }, { from: 'S0', to: 'N2' },
            { from: 'N1', to: 'G2' }, { from: 'N1', to: 'G3' },
            { from: 'N2', to: 'N3' }, { from: 'N3', to: 'N4' }, { from: 'N4', to: 'S0', dashed: true },
            { from: 'G1', to: 'S0', dashed: true }, { from: 'G2', to: 'S0', dashed: true }, { from: 'G3', to: 'S0', dashed: true },
        ];

        let currentMode = 'RL';
        let agents = [];
        let simStats = {
            totalVisits: 0,
            visits: {}
        };
        // Initialize visit counters for all nodes so metrics start valid (not NaN/N/A)
        nodes.forEach(n => simStats.visits[n.id] = 0);
        for (let i = 0; i < 80; i++) agents.push({ curr: 0, target: null, prog: 0, speed: 0.02 + Math.random() * 0.02 });
        function setMode(mode) {
            currentMode = mode;

            // UI Updates
            document.querySelectorAll('#tab1 button').forEach(b => b.classList.remove('active'));
            if (mode == 'RL') document.getElementById('btn-rl').classList.add('active');
            if (mode == 'RANDOM') document.getElementById('btn-rand').classList.add('active');
            if (mode == 'DDGC') document.getElementById('btn-ddgc').classList.add('active');

            // --- NEW: Reset Stats ---
            simStats.totalVisits = 0;
            // Reset individual node counters to 0
            nodes.forEach(n => simStats.visits[n.id] = 0);
        }

        function getNextNode(currIdx) {
            const node = nodes[currIdx];
            if (node.type === 'goal' || node.id === 'N4') return 0;
            const opts = connections.filter(c => c.from === node.id);
            if (opts.length === 0) return 0;

            if (node.id === 'S0') {
                if (currentMode === 'RL') return nodes.findIndex(n => n.id === opts[0].to);
                if (currentMode === 'RANDOM') {
                    const r = Math.random();
                    if (r < 0.33) return nodes.findIndex(n => n.id === opts[0].to);
                    if (r < 0.66) return nodes.findIndex(n => n.id === opts[1].to);
                    return nodes.findIndex(n => n.id === opts[2].to);
                }
                if (currentMode === 'DDGC') {
                    return Math.random() < 0.35 ? nodes.findIndex(n => n.id === opts[0].to) : nodes.findIndex(n => n.id === opts[1].to);
                }
            }
            if (node.id === 'N1') return Math.random() < 0.5 ? nodes.findIndex(n => n.id === opts[0].to) : nodes.findIndex(n => n.id === opts[1].to);
            return nodes.findIndex(n => n.id === opts[0].to);
        }

        function animateSim() {
            if (!isSimRunning) return;
            ctx.clearRect(0, 0, LOGICAL_W, LOGICAL_H);

            // --- Draw Areas & Graph (No changes here) ---
            ctx.fillStyle = '#e8f0fe'; ctx.beginPath(); ctx.roundRect(310, 150, 230, 228, 15); ctx.fill();
            ctx.fillStyle = '#fce8e6'; ctx.beginPath(); ctx.roundRect(620, 100, 160, 280, 15); ctx.fill();
            ctx.textAlign = 'center';
            ctx.fillStyle = '#1558d6'; ctx.font = 'bold 14px Arial'; ctx.fillText("Discount Horizon", 425, 390);
            ctx.fillStyle = '#a50e0e'; ctx.font = 'bold 14px Arial'; ctx.fillText("Entropy Trap", 700, 400);

            connections.forEach(c => {
                const n1 = nodes.find(n => n.id == c.from); const n2 = nodes.find(n => n.id == c.to);
                ctx.beginPath(); ctx.moveTo(n1.x, n1.y); ctx.lineTo(n2.x, n2.y);
                ctx.strokeStyle = c.dashed ? '#ddd' : '#bbb'; ctx.lineWidth = 2;
                if (c.dashed) ctx.setLineDash([5, 5]); else ctx.setLineDash([]); ctx.stroke(); ctx.setLineDash([]);
            });

            nodes.forEach(n => {
                ctx.beginPath(); ctx.arc(n.x, n.y, NODE_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = n.type == 'start' ? '#4285F4' : n.type == 'goal' ? '#34A853' : '#EA4335';
                ctx.fill(); ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = 'bold 12px Arial'; ctx.fillText(n.label, n.x, n.y);
            });

            // --- NEW: Agent Loop with Tracking ---
            // ... (Drawing code remains the same) ...

            // --- UPDATED: Agent Loop with Full Tracking ---
            let trapOccupancy = 0;

            agents.forEach(a => {
                // 1. Check if agent is currently inside the "Trap" (Occupancy Metric)
                const currentNodeId = nodes[a.curr].id;
                if (currentNodeId === 'N2' || currentNodeId === 'N3' || currentNodeId === 'N4') {
                    trapOccupancy++;
                }

                // 2. Move Agent
                if (a.target === null) a.target = getNextNode(a.curr);
                a.prog += a.speed;

                // 3. Agent Arrives at Node
                if (a.prog >= 1) {
                    // Record the visit to THIS specific node
                    const targetNodeId = nodes[a.target].id;

                    simStats.visits[targetNodeId]++; // Track specific node
                    simStats.totalVisits++;          // Track total steps globally

                    a.curr = a.target; a.target = null; a.prog = 0;
                }

                if (a.target !== null) {
                    const n1 = nodes[a.curr], n2 = nodes[a.target];
                    const x = n1.x + (n2.x - n1.x) * a.prog; const y = n1.y + (n2.y - n1.y) * a.prog;
                    ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI * 2); ctx.fillStyle = '#202124'; ctx.fill();
                }
            });

            // --- UPDATED: Live Metric Calculation ---

            // 1. Diversity (Normalized Shannon Entropy on GOALS only)
            // We filter our full stats to look only at G1, G2, G3
            const g1 = simStats.visits['G1'];
            const g2 = simStats.visits['G2'];
            const g3 = simStats.visits['G3'];
            const trapVisits = simStats.visits['N2'] + simStats.visits['N3'] + simStats.visits['N4'];
            const startVisits = simStats.visits['S0'];
            const totalGoalVisits = g1 + g2 + g3;
            const totalVisits = totalGoalVisits + trapVisits + startVisits;

            let entropy = 0;
            if (totalGoalVisits > 0) {
                [g1, g2, g3].forEach(count => {
                    const p = count / totalVisits;
                    if (p > 0) entropy -= p * Math.log(p);
                });
            }
            const divScore = entropy

            // 2. Return (Efficiency)
            // Ratio of "Goal Visits" to "Total Visits"
            // Optimal agents hit goals frequently. Confused agents hit transition nodes/traps.
            let retScore = 0;
            if (simStats.totalVisits > 0) {
                // Multiplier 12 maps the efficiency ratio to a 0-10 scale visually
                retScore = (totalGoalVisits / simStats.totalVisits) * 12;
            }
            if (retScore > 9.9) retScore = 9.9;

            // 3. Waste (Instantaneous Occupancy)
            const wasteScore = (trapOccupancy / agents.length) * 100;

            // --- Update DOM ---
            document.getElementById('t1-ret').innerText = retScore.toFixed(1);
            document.getElementById('t1-div').innerText = divScore.toFixed(2);
            document.getElementById('t1-waste').innerText = Math.round(wasteScore) + '%';

            if (wasteScore > 20) document.getElementById('t1-waste').style.color = '#EA4335';
            else document.getElementById('t1-waste').style.color = '#5f6368';

            requestAnimationFrame(animateSim);
        }
        animateSim();

        // ==========================================
        // TAB 2: ALGORITHM LOGIC (SEQUENTIAL)
        // ==========================================
        const goals = ['G1', 'G2', 'G3', 'G4'];
        let mixture = [0.8, 0.1, 0.1, 0.0];
        let iteration = 0;
        let algoStage = 0; // 0=Idle, 1=Reward, 2=Policy

        // Helper to draw bars
        function renderBars(id, vals, col) {
            const c = document.getElementById(id); c.innerHTML = '';
            vals.forEach((v, i) => {
                const b = document.createElement('div'); b.className = 'bar';
                b.style.height = (v * 100) + '%'; b.style.backgroundColor = col;
                const l = document.createElement('div'); l.className = 'bar-label'; l.innerText = goals[i];
                b.appendChild(l); c.appendChild(b);
            });
        }

        // State Data (Kept global to persist between clicks)
        let currMixture = [...mixture];
        let currRewards = [];
        let currPolicy = [];

        function advanceAlgo() {
            const btn = document.getElementById('btn-sequence');
            const box1 = document.getElementById('box-1');
            const box2 = document.getElementById('box-2');
            const box3 = document.getElementById('box-3');
            const arrow = document.getElementById('feedback-arrow');

            if (algoStage === 0) {
                // --- STEP 1: CALCULATE REWARDS ---
                // Inverse of visitation (simplify 1-p for visual)
                currRewards = currMixture.map(p => Math.max(0, 1 - p));
                renderBars('chart-reward', currRewards, '#EA4335');

                // Highlight Box 2, Dim Box 1
                box1.classList.remove('active-box');
                box2.classList.add('active-box');

                btn.innerText = "2. Train Policy";
                algoStage = 1;
            }
            else if (algoStage === 1) {
                // --- STEP 2: TRAIN POLICY ---
                // Greedy selection of max reward
                let maxR = -1, bestIdx = 0;
                currRewards.forEach((r, i) => { if (r > maxR) { maxR = r; bestIdx = i; } });
                currPolicy = [0, 0, 0, 0]; currPolicy[bestIdx] = 1.0;
                renderBars('chart-policy', currPolicy, '#34A853');

                // Highlight Box 3
                box2.classList.remove('active-box');
                box3.classList.add('active-box');

                btn.innerText = "3. Update Mixture";
                algoStage = 2;
            }
            else if (algoStage === 2) {
                // --- STEP 3: UPDATE MIXTURE (LOOP) ---
                iteration++;
                const lr = 2 / (iteration + 2);

                // Frank-Wolfe Update
                currMixture = currMixture.map((old, i) => (1 - lr) * old + lr * currPolicy[i]);

                // Show Feedback Arrow
                arrow.classList.add('visible');

                // Wait 600ms for visual effect, then reset to start
                setTimeout(() => {
                    renderBars('chart-mixture', currMixture, '#4285F4');

                    // Reset Highlights to Box 1
                    box3.classList.remove('active-box');
                    box1.classList.add('active-box');
                    arrow.classList.remove('visible');

                    // Clear intermediate charts for cleanliness
                    document.getElementById('chart-reward').innerHTML = '';
                    document.getElementById('chart-policy').innerHTML = '';

                    // Update labels
                    document.getElementById('iter-count').innerText = iteration;
                    document.getElementById('lambda-val').innerText = lr.toFixed(2);

                    btn.innerText = "1. Calculate Reward";
                    algoStage = 0;

                    // Ensure math renders if changed
                    if (window.MathJax) MathJax.typeset();
                }, 600);
            }
        }

        // --- ACCORDION LOGIC ---
        function toggleAccordion(element) {
            const item = element.parentElement;
            const content = item.querySelector('.accordion-content');

            // Close others (Optional - remove this block if you want multiple open)
            document.querySelectorAll('.accordion-item').forEach(i => {
                if (i !== item && i.classList.contains('open')) {
                    i.classList.remove('open');
                    i.querySelector('.accordion-content').style.maxHeight = null;
                }
            });

            // Toggle current
            item.classList.toggle('open');
            if (item.classList.contains('open')) {
                content.style.maxHeight = content.scrollHeight + "px";
            } else {
                content.style.maxHeight = null;
            }
        }

        function resetAlgo() {
            currMixture = [0.8, 0.1, 0.1, 0.0];
            iteration = 0;
            algoStage = 0;
            renderBars('chart-mixture', currMixture, '#4285F4');
            document.getElementById('chart-reward').innerHTML = '';
            document.getElementById('chart-policy').innerHTML = '';

            // Reset Highlights
            document.getElementById('box-1').classList.add('active-box');
            document.getElementById('box-2').classList.remove('active-box');
            document.getElementById('box-3').classList.remove('active-box');
            document.getElementById('feedback-arrow').classList.remove('visible');

            document.getElementById('btn-sequence').innerText = "1. Calculate Reward";
            document.getElementById('iter-count').innerText = 0;
        }
        // Initialize
        resetAlgo();
    </script>
</body>

</html>